# 状态模式
&emsp;&emsp;当一个对象的内在状态改变时，允许改变其行为，这个对象看起来是改变了其类。状态模式主要解决的是当控制一个对象状态转换的条件表达式过于复杂的情况，把状态的判断逻辑转移到表示不同状态的一系列类当中，可以把复杂的判断逻辑简单化（当然如果这个判断很简单就没必要使用状态模式了）。<br>
&emsp;&emsp;状态模式的好处就是将特定的状态相关的行为都放入一个对象中，由于所有与状态相关的代码都存在于某个具体状态中，所以可以通过定义新的子类可以很容易地增加新的状态和转换。这样的做既消除庞大的条件分支语句，也将各种状态转移逻辑分布到了各个状态子类中，减少了互相的依赖。<br>
&emsp;&emsp;简单点说，就是我们有一个主类，要根据状态不同，进行一系列不同的操作，现在定义一个状态父类，并定义一系列状态子类，并在主类中通过父状态类引用某个具体的状态，在主类某个方法中，把主类对象传给某个状态子类，在这个状态子类操作主类完成主类在当前要执行的工作，并根据当前状态来判断下一个状态设置给主类。也就是说下一个状态是在具体的状态子类中完成的，主类要在某一个状态进行的工作，也是在某一个字状态类中完成的。<br>
&emsp;&emsp;那么什么时候时候用状态模式呢？当一个对象的行为取决于它的状态，并且它必须在运行时候根据状态改变它的行为时，就可以考虑使用状态模式了。而且如果我们要增加一个状态，只需要新增一个状态子类，并更改某个类的判断逻辑即可。<br>

- [参考代码](https://github.com/zhangonga/design-patterns/tree/master/src/main/java/tech/zg/patterns/behavior/behavior4_state_patterns)<br>
- [返回首页](https://github.com/zhangonga/design-patterns#%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E7%AC%94%E8%AE%B0)