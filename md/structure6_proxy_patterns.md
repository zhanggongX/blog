# 代理模式

&emsp;&emsp;代理模式：为其他对象提供一种代理，以控制对这个对象的访问。例如我们找房子，通过中介来找，就是代理模式，我们没有接触到房屋源，但是我们通过中介，就能找到合适的房子。<br>
&emsp;&emsp;代理模式和装饰模式:<br>
&emsp;&emsp;相同点，就代码结构上而言，它和装饰模式很像，都是代理类/装饰类，和被代理类/被装饰类实现同一个接口，然后代理类/装饰类持有一个被代理类/被装饰类一个引用，这样很容易的在被代理类/被装饰类方法前或者后加上自定义的一些方法。<br>
&emsp;&emsp;不同点，实际上代理模式和装饰模式还是有很多区别的。**装饰模式关注于在给一个对象动态的增加方法，而代理模式关注于控制对象的访问，通俗的讲，用代理模式，代理类可以对他的客户端隐藏一个对象的具体信息，因此当使用代理模式的时候，我们常常在一个代理类创建一个具体的对象的实例，而装饰模式，我们通常的做法是将原始对象作为一个参数传给装饰者的构造器**。<br>
&emsp;&emsp;一句话代理模式和装饰者模式的区别，**使用代理模式，代理和真实对象之间的关系通常在编译时就已经确定了，例如在代理类的构造函数里创建一个被代理类的对象，而装饰者模式能够在运行时递归地被构造，比如在装饰类的构造函数里增加一个被装饰类的参数，所以看起来调用者不知道代理模式代理了什么，而调用者知道装饰模式，装饰了什么**。
- [参考代码](https://github.com/zhangonga/design-patterns/tree/master/src/main/java/tech/zg/patterns/structure/structure6_proxy_patterns)<br>
- [返回首页](https://github.com/zhangonga/design-patterns#%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E7%AC%94%E8%AE%B0)