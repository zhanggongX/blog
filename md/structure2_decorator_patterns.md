# 装饰模式

&emsp;&emsp;装饰模式，就是动态的给对象添加额外的职责，就增加功能来说，装饰模式比生成子类更为灵活。<br>
&emsp;&emsp;装饰模式具体的操作，就是定义一个装饰父类，继承被装饰类同一个父类，或者实现被装饰类同一个接口，或者干脆继承被装饰类，然后在装饰类中，就可以持有一个被装饰类了，然后在调用被装饰类前和调用完后都可以增加装饰类想添加的东西。这样就相当于给被装饰类进行了装饰。<br>
&emsp;&emsp;上边说的多种装饰情况下，如果只有一种装饰情况，也可以直接写一个装饰类来实现装饰。<br>
&emsp;&emsp;装饰模式是为已有功能动态地添加更多功能的一种方式，那么时候什么时候合适使用呢？<br>
&emsp;&emsp;假设我们有一个已经成熟的类，已经有很多的地方再使用这个类了，如果我们有新需求，需要增加一些功能，而这些功能又不是这个类的核心功能，这种情况下，就可以使用装饰模式了。<br>
&emsp;&emsp;装饰模式的优点正是，把类中的装饰功能从类中搬移出去，这样可以简化原有的核心类。这样有效的把类的核心功能和装饰的功能分开了，而且可以去除相关类的重复的装饰逻辑。<br>
&emsp;&emsp;装饰模式和建造者模式的异同:<br>
&emsp;&emsp;相同点：建造者模式是所有的部件在内部组装完毕之后，然后显示出来，装饰模式似乎与其有着共同之处，那就是你不能在人前一件一件地穿衣服，你肯定会在某个别人看不见的地方把衣服穿好，才出来见人的。<br>
&emsp;&emsp;不同点：建造者模式要求建造的过程必须是稳定的。而装饰模式的建造过程不是稳定的，衣服你可以先穿裤子，再穿褂子，或者干脆不穿褂子，穿个短袖等等，是内部的建造过程不是稳定的。<br>


&emsp;&emsp;详见代码 [structure2_decorator_patterns](https://github.com/zhangonga/design-patterns/tree/master/src/main/java/tech/zg/patterns/structure/structure2_decorator_patterns)

- [返回首页](https://github.com/zhangonga/design-patterns#%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E7%AC%94%E8%AE%B0)