#设计模式

为什么要考虑用设计模式？

简单的java API学完后，任何人都可以来开发java程序，只需要按照需求把功能实现即可，但是几乎没有不变的需求，需求更改了，程序必然也要跟着修改，这时候好代码和坏代码的优略势就很明显了，例如古代雕版印刷，一个雕版就相当于一个程序，再活字印刷术发明之前，印刷一个通告，就要雕刻一个整版，有一个地方要改，无论增删改查就要全部重来。
而发明了活字印刷术之后呢，第一，要改某个字，只需改这个字即可，这是可维护性，第二，已经用过的字，还可以用，这是可复用性，第三，若是要加字，只需要往里添加即可，这是灵活性好。这就是好代码的优势。
而学习设计模式，就是再开发的过程中，通过灵活使用封装、继承、多态把程序的耦合度降低，从而把程序写的更加灵活，且易于复用。
##1	创建型模式

-[1.1 简单工厂模式](https://github.com/zhangonga/design-patterns/blob/master/md/create1_simple_factory_pattern.md)
-[1.2 单例]()
-[1.3 工厂方法]()
-[1.4 抽象工厂方法]()
-[1.5 建造者模式]()
-[1.6 原型模式]()

##2 结构型

-[2.1 适配器模式]()
-[2.2 装饰模式]()
-[2.3 桥接模式]()
-[2.4 组合模式]()
-[2.5 享元模式]()
-[2.6 代理模式]()
-[2.7	外观模式]()

##3 行为型

-[3.1 观察者模式]()
-[3.2 模板方法]()
-[3.3 命令模式]()
-[3.4 状态模式]()
-[3.5 职责链模式]()
-[3.6 解释器模式]()
-[3.7 中介模式]()
-[3.8 访问者模式]()
-[3.9 策略模式]()
	策略模式是一种定义了一系列算法的模式，从概念上来砍，所有这些算法完成的都是相同的工作，只是实现不同，它可以以相同的方式调用所有的算法，减少了各种算法类与使用类的耦合。
详见代码behavior9。
策略模式和简单工厂模式的区别，看上去很像，都是根据多态，通过不同的条件，来使用不同的对象进行解耦。但是他们是有本质的区别的，一个是创建型的模式，一个是行为型的模式，工厂模式的具体算法选型交给了调用方，而策略模式则把算法的选型交给了提供方。一个是我要把使用的类型传递给工厂，然后获得具体的算法类，然后再去计算。一种是传递给策略上下文，然后直接调用即可，而不用关心调用的那个方法，因为策略的上下文有具体的算法的引用。
什么时候使用策略模式呢？策略模式就是用来封装算法的，它可以用来封装几乎任何类型的规则，所以在我们实际工作中，如果听到在不同时间应用不同的业务规则，就可以考虑使用策略模式来处理这种变化的可能性。当然策略模式，大多数情况下，可以被工厂模式所取代。
-[3.10 备忘录模式]()
-[3.11 迭代器模式]()

##一些原则
单一职责
开放-封闭
迪米特法则
